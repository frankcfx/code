课程安排
===============================================
  Scala -> 1天
  SparkCore -> 2天
    类比MapReduce学习
  SparkSQL -> 1天
    类比Hive学习
  Kafka -> 1天
  SparkStreaming -> 1天
  Spark项目 -> 2天
  晚自习：
    Spark2.x -> 4个课时
	晚自习会讲课堂上布置的作业以及答疑
	
===============================================
IDEA安装过程中注意的事项
  -1. 在开发之前，必须将字符集设置为UTF-8

IDEA快捷键
  ctrl + N: 查找类，两次表示查找依赖包中的类
  ctrl + F12: 查看当前类中的方法/属性，两次表示查找父类中的方法/属性
  alt + Enter：
    前提要求：鼠标必须放到异常的位置(红线的位置)/需要提示的位置
	万能的快捷键，eg：导入包、数据类型的自动生成、异常提示等

Spark授课过程中的所有项目要求：
  (必须要求)所有项目的项目路径中不允许存在空格和中文

===============================================
var和val的区别?? 一个变量，一个是常量；val修饰的不可变/不可以重新赋值的变量，类似Java中的final修饰的变量；var修饰可变变量
  scala推荐优先使用val不可变变量，除非业务需要，否则坚决不用var

表达式：
  在编程过程中，任何一个可执行的代码均是一个表达式；一般使用大括号括起来

scala中的返回值
  -1. scala中所有代码均有返回值
  -2. 返回值不适用return语句，return语句大家最好不要用(而且只在while/do-while中使用有效)
  -3. scala中的代码返回值其实是最后一行代码/最后一个表达式的执行结果
  -4. 在高阶函数调用过程中，下划线表示参数占位，表示第几个输入参数
  -5. 在import导包的时候，下划线表示导入所有子包和包中的class/object
  
scala中代码换行规则：
  -1. 可以使用java基于分号的换行规则（不建议）
  -2. scala基于代码的一个推断进行代码管理，一般情况下，认为一行就是一段代码
  

下划线在scala中的作用：
  -1. 在var变量初始化的时候，给定默认值/初始值
  -2.
  -3. 在将函数赋值给变量的过程中，下划线表示参数占位
  
懒加载：
  只要当变量第一次使用的时候(被调用), 才会进行初始化，并且只会进行一次初始化操作

String类型的使用/方法：
  基本和Java中的字符串使用方式类似
  提供了一些额外的方法或者API：
    val str1 = "my name is gerry"
	val str2 = """my name is gerry"""
	val str3 = "my name is \"gerry\""
	val str4 = """my name is "gerry""""
	val str5 = """
	  | my name is gerry
	""".stripMargin
	val name = "  gerry  "
	println("my name is " + name)
	println("my name is %s".format(name))
	println(s"my name is $name")
	println(s"my name is ${name.trim}")
	
scala中的操作符
  基本和java一样，优先级和java一样(实在搞不定优先级的时候，直接使用小括号)特殊：
    -1. Scala中的操作符实际上是对应变量的一个方法 ==> 底层其实就是一个类的API, eg：1 + 2 <---> 1.+(2)  
	-2. scala的函数API可以写成操作符的形式,eg: 1.to(10) <==> 1 to 10;
	-3. 所有以数字、字母开头的操作符优先级仅仅只比赋值操作符优先级高
	-4. 除了以":"开头的操作符，其它操作符均是左连接
	-5. 不支持三元操作符(?:)、不支持++\--
  
==================================================
Scala中产生集合的便捷方式
  0 to 10: 0到10，步长为1，产生一个[0,10]区间的集合 <===> 0.to(10) <===> 0.to(10,1) 
  0 until 10: 0到10，步长为1，产生一个[0,10)区间的集合 <===> 0.until(10) <===> 0.until(10,1)
  Range(0,10): 0到10，步长为1，产生一个[0,10)区间的集合 <===> Range(0,10, 1)
  
Scala不支持break和continue关键字，但是这两个单词是保留的；一般通过其它方式实现类似的功能：Breaks类、for循环的守护模式等
while、do-while的语法和java的一模一样
  
Java中的for循环
  for(int i=0;i<length;i++){
    .....普通的for循环
  }
  for (int temp : array) {
    .....增强for循环
  }
Scala中的for循环类似Java的增强for循环
  for (temp <- array) {
    .....
  }
================================================
Scala函数
  函数是一等公民 ==> 函数可以独立存在，不依赖任何的类或者对象，可以将函数赋值给任何其它的变量，也可以出现在任何的地方(eg: 类、对象、函数中.....)

  def max(x: Int, y: Int): Int = {
    if (x > y) {
      println(s"grant x:${x}")
      x
    } else {
      println(s"grant y:${y}")
      y
    }
  }
max: (x: Int, y: Int)Int

scala> max(12, 13)
grant y:13
res53: Int = 13
scala> max(y=12,x=23)
grant x:23
res66: Int = 23

  (Int, Int) => Int ---> 一般采用这种形式表示一个函数，而且这个函数的输入参数两个，均为Int类型，函数的返回值也为Int类型
  函数的定义: f: T => R
     T表示函数的输入参数的数据类型
	 R表示函数的返回值数据类型

scala> val max2 = max _
max2: (Int, Int) => Int = <function2>
scala> max2(12, 13)
grant y:13
res76: Int = 13

val max3 = (x: Int, y: Int) => {
    if (x > y) {
      println(s"grant x:${x}")
      x
    } else {
      println(s"grant y:${y}")
      y
    }
  }
匿名函数：没有函数名称的函数就叫做匿名函数，一般情况下，会将匿名函数赋值给赋值给一个变量然后使用
注意：匿名函数最多允许22个输入参数，匿名函数在scala内实际上是FunctionX类型接口的实现(特质)
(x:Int, y:Int) => {
  x + y
}

高阶函数
  函数的输入参数中有参数的数据类型是函数，那么函数就叫做高阶函数
    // 高阶函数的简化
    // 1. 可以将输入参数的类型省略，原因是：scala的编译器会自动的根据函数定义的上下文推断此处的数据输入类型是啥
    greeting("gerry", (name) => println(s"nihao,${name}"))
    oper(10, 12, (a, b) => a + b)
    // 2. 当输入参数只有一个的时候，可以省略小括号
    greeting("gerry", name => println(s"nihao,${name}"))
    oper(10, 12, (a, b) => a + b)
    // 3. 如果左侧的所有输入参数在右侧的函数体中均被使用，而且满足一下条件:
    // a. 参数有且仅使用一次
    // b. 参数的使用顺序和输入参数的顺序一致
    // 当满足上述两个条件的时候，就可以省略输入参数，使用下划线代替(备注：省略之后没有异议，可以自动推断出类型)
    //    greeting("gerry", println(s"nihao,${_}")) // 报错，原因在于：没法进行format格式化
    oper(10, 12, _ + _) // 第一个下划线表示函数的第一个输入参数，第二个下划线表示函数的第二个输入参数

================================================
数组
  不可变数组
    仅仅支持数组数据的更新、获取、遍历操作
  可变数组
    支持数组数据的更新、获取、遍历操作 + 添加、删除元素等操作
  索引从0开始，如果索引越界会报错
  构建方式和Java不太一样，使用Array/ArrayBuffer进行构建
  数组元素获取是通过小括号+索引的形式获取，和java中不一样
  

元组
  元组中的数据的数据类型可以是一样的，也可以是不一样的，在存储的时候，会同时将数据的数据类型进行存储
  元组中的数据的方式其实是基于属性进行访问，但是可以看成是下划线+索引的方式，索引从1开始
  元组scala底层对应的数据类型是TupleX类型的class
  最小的元组是一元组，最大的元组是二十二元组
  元组中的数据类型可以是任意的scala的有效数据类型
  元组中的元素不允许重新赋值(但是可以改对应对象中的属性)


可变集合和不可变集合比较来讲：
   因为不可变集合中的元素数量不会发生变化，所以内存的申请不需要多次申请(只需要在集合构建的时候，给定内存大小即可) ==> 所以不可变集合相对来将性能比可变集合要好 ==> scala推荐优先使用不可变集合



